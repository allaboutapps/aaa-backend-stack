import * as inquirer from "inquirer";
import * as _ from "lodash";
import { defineCLIEnvironment, CLI, FS_EXTRA, SEMVER } from "@aaa-backend-stack/build-tools";
import * as path from "path";
import { execAsync, GLOB_PROMISE, hashing } from "@aaa-backend-stack/utils";
import * as uuid from "uuid/v4";

// Attention: This environment is expected by the cabgen files in the template project, ensure you don't forget to adapt your changes there!
export interface ICabgenEnvironment {
    // autogenerated or constant
    CAB_AAA_BACKEND_STACK_COMMIT: string; // <%= CAB_AAA_BACKEND_STACK_COMMIT %>
    CAB_PROJECT_NAME: string; // <%= CAB_PROJECT_NAME %>

    CAB_PKG_DESCRIPTION: string; // <%= CAB_PKG_DESCRIPTION %>
    CAB_PKG_VERSION: string; // <%= CAB_PKG_VERSION %>

    CAB_DOCKER_IMAGE_TAG: string; // <%= CAB_DOCKER_IMAGE_TAG %>
    CAB_DOCKER_CONTAINER_SETUP_NAME: string; // <%= CAB_DOCKER_CONTAINER_SETUP_NAME %>

    CAB_POSTGRES_USER: string; // <%= CAB_POSTGRES_USER %>
    CAB_POSTGRES_DB: string; // <%= CAB_POSTGRES_DB %>
    CAB_POSTGRES_TEST_DB: string; // <%= CAB_POSTGRES_TEST_DB %>
    CAB_POSTGRES_PASSWORD: string; // <%= CAB_POSTGRES_PASSWORD %>

    CAB_PGHERO_PASSWORD: string; // <%= CAB_PGHERO_PASSWORD %>

    CAB_MONITORING_ADMIN_SECRET: string; // <%= CAB_MONITORING_ADMIN_SECRET %>

    // asked through inquirer, this won't be stored in the plain .cabgen file
    // (but hash + salt will be written to migration files)
    CAB_ROOT_ADMIN_PASSWORD_PLAIN: string; // <%= CAB_ROOT_ADMIN_PASSWORD_PLAIN %>
    CAB_ROOT_ADMIN_PASSWORD_HASH: string; // <%= CAB_ROOT_ADMIN_PASSWORD_HASH %>
    CAB_ROOT_ADMIN_PASSWORD_SALT: string; // <%= CAB_ROOT_ADMIN_PASSWORD_SALT %>

    // asked through inquirer
    CAB_VAGRANT_IP: string; // <%= CAB_VAGRANT_IP %>

    CAB_USER_ROOT_UID: string; // <%= CAB_USER_ROOT_UID %>
    CAB_PERMISSION_ROOT_UID: string; // <%= CAB_PERMISSION_ROOT_UID %>
    CAB_PERMISSION_CMS_UID: string; // <%= CAB_PERMISSION_CMS_UID %>
}

export async function getCabgenEnvironment(projectDir: string, commit: string, yesToAll: boolean): Promise<ICabgenEnvironment> {

    const passwordGenerator = require("generate-password");

    const rootUserPassword = passwordGenerator.generate({
        length: 10,
        numbers: true
    });

    const defaultValues: ICabgenEnvironment = {
        // autogenerated or constant
        CAB_AAA_BACKEND_STACK_COMMIT: commit,
        CAB_PROJECT_NAME: projectDir,

        CAB_PKG_DESCRIPTION: `a create-aaa-backend scaffolded project by allaboutapps`,
        CAB_PKG_VERSION: `0.1.0`,

        CAB_DOCKER_IMAGE_TAG: "allaboutapps/" + projectDir.split("-").join("_") + "_image",
        CAB_DOCKER_CONTAINER_SETUP_NAME: projectDir.split("-").join("_") + "_container",

        CAB_POSTGRES_USER: "dbuser",
        CAB_POSTGRES_DB: projectDir + "-db",
        CAB_POSTGRES_TEST_DB: projectDir + "-test-db",
        CAB_POSTGRES_PASSWORD: passwordGenerator.generate({
            length: 10,
            numbers: true
        }),
        CAB_PGHERO_PASSWORD: passwordGenerator.generate({
            length: 10,
            numbers: true
        }),

        CAB_MONITORING_ADMIN_SECRET: passwordGenerator.generate({
            length: 10,
            numbers: true
        }),

        // asked through inquirer (default values or yesToAll flag)
        CAB_VAGRANT_IP: "10.0.0.30",

        // defaults with utils.hashing.pbkdf2Late2016 
        CAB_ROOT_ADMIN_PASSWORD_PLAIN: rootUserPassword,
        CAB_ROOT_ADMIN_PASSWORD_HASH: null,
        CAB_ROOT_ADMIN_PASSWORD_SALT: null,

        CAB_USER_ROOT_UID: uuid(),
        CAB_PERMISSION_ROOT_UID: uuid(),
        CAB_PERMISSION_CMS_UID: uuid(),
    };

    if (yesToAll) {
        // Create salt and hash password using default generated random password
        defaultValues.CAB_ROOT_ADMIN_PASSWORD_SALT = await hashing.pbkdf2Late2016.createSalt();
        defaultValues.CAB_ROOT_ADMIN_PASSWORD_HASH = await hashing.pbkdf2Late2016.hashPassword(defaultValues.CAB_ROOT_ADMIN_PASSWORD_PLAIN, defaultValues.CAB_ROOT_ADMIN_PASSWORD_SALT);

        return defaultValues;
    }

    const { CAB_ROOT_ADMIN_PASSWORD_PLAIN, ...answers } = await inquirer.prompt([{
        type: "input",
        name: "CAB_VAGRANT_IP",
        message: `CAB_VAGRANT_IP: Which IP should be configured for your Vagrant VM?`,
        default: function () {
            return defaultValues.CAB_VAGRANT_IP;
        }
    }, {
        type: "password",
        name: "CAB_ROOT_ADMIN_PASSWORD_PLAIN",
        message: `CAB_ROOT_ADMIN_PASSWORD_PLAIN: Which password should we set for your root application user (inserted as migration, hashed+salted, allowed to access docs)?`,
        default: function () {
            return rootUserPassword;
        }
    }]);

    const ipaddr = require("ipaddr.js");

    if (ipaddr.isValid(answers.CAB_VAGRANT_IP) === false) {
        throw new Error(`Received invalid ip address ${answers.CAB_VAGRANT_IP} received.`);
    }

    // we use the latest available hashing algorithm...
    const CAB_ROOT_ADMIN_PASSWORD_SALT = await hashing.pbkdf2Late2016.createSalt();
    const CAB_ROOT_ADMIN_PASSWORD_HASH = await hashing.pbkdf2Late2016.hashPassword(CAB_ROOT_ADMIN_PASSWORD_PLAIN, CAB_ROOT_ADMIN_PASSWORD_SALT);

    return {
        ...defaultValues,
        ...answers,
        CAB_ROOT_ADMIN_PASSWORD_SALT,
        CAB_ROOT_ADMIN_PASSWORD_HASH,
        CAB_ROOT_ADMIN_PASSWORD_PLAIN
    };
}

export async function saveCabgenEnvironment(projectDir: string, cabenv: ICabgenEnvironment) {
    const cabgenFile = path.join(projectDir, "cabgen.json");
    await FS_EXTRA.writeJSON(cabgenFile, cabenv, { spaces: 2 });
    CLI.info(`Saved "${cabgenFile}".`);
}

export async function expandCabgenDirectories(absolutePathToProject: string) {
    // all files inside .cabgen directories in any deep of the project must be recursively moved into their parent directory
    CLI.debug(`Expanding **/.cabgen directories into their parent directory...`);
    const cabgenDirs = await GLOB_PROMISE("**/.cabgen", { cwd: absolutePathToProject, dot: true, });

    CLI.debug(`Found cabgenDirs: ${cabgenDirs}`);

    await Promise.each(cabgenDirs, async (cabgenDir) => {
        const sourceDir = path.resolve(absolutePathToProject, cabgenDir);

        const subDirectories = await GLOB_PROMISE("**/", { cwd: sourceDir, dot: true });
        if (subDirectories.length > 0) {
            throw new Error(`.cabgen directory at ${sourceDir} has additional subdirectories: ${subDirectories}! This is not allowed.`);
        }

        // https://stackoverflow.com/questions/42956127/get-parent-directory-name-in-node-js
        const targetDirectory = path.resolve(path.dirname(sourceDir).split(path.sep).pop());

        CLI.debug(`Getting files in cabgenDir sourceDir: ${sourceDir} targetDirectory: ${targetDirectory}`);
        const files = await GLOB_PROMISE("*", { cwd: sourceDir, dot: true });

        await Promise.each(files, async (file) => {
            const fileAbsolute = path.resolve(sourceDir, file);
            const basename = path.basename(file);
            const targetFileAbsolute = path.join(targetDirectory, basename);
            CLI.debug(`Moving file ${file} basename: ${basename} targetFile: ${targetFileAbsolute}`);
            await FS_EXTRA.move(fileAbsolute, targetFileAbsolute);
        });

    });

    CLI.info(`Expanded ${cabgenDirs.length} **/.cabgen directories.`);

    // finally remove all .cabgen dirs...
    await Promise.each(cabgenDirs, async (cabgenDir) => {
        const sourceDir = path.resolve(absolutePathToProject, cabgenDir);
        CLI.debug(`Removing .cabgen dir ${sourceDir}`);
        await FS_EXTRA.remove(sourceDir);
    });
}

export async function applyCabgenTemplates(absolutePathToProject: string, cabEnvironment: ICabgenEnvironment) {
    // any *.cabgen files in the template project are found, parsed (lodash template) and overwrite the the file (if existing)

    CLI.debug(`Applying **/*.cabgen templates in ${absolutePathToProject}...`);
    const cabgenTemplates = await GLOB_PROMISE("**/*.cabgen", { cwd: absolutePathToProject, dot: true });

    await Promise.each(cabgenTemplates, async (cabgenTemplate) => {
        const templatePath = path.join(absolutePathToProject, cabgenTemplate);
        const targetPath = templatePath.replace(".cabgen", "");

        CLI.debug(`Reading "${templatePath}"...`);

        const templateContent = (await FS_EXTRA.readFile(templatePath)).toString();

        CLI.debug(`Compiling "${templatePath}"...`);
        const templateFn = _.template(templateContent, {
            interpolate: /<%=([\s\S]+?)%>/g // see https://github.com/lodash/lodash/issues/399 - disallow ES& template strings
        });

        CLI.debug(`Executing "${templatePath}"...`);
        const parsedContent = templateFn({
            ...cabEnvironment,
            // allow .cabgen templates to directly use require and operate in the projectPath
            __projectPath: absolutePathToProject,
            __targetPath: targetPath,
            path,
            require
        });

        // As .cabgen files are allowed to require their targetFile, remove it after applying the template!
        const targetExists = await FS_EXTRA.pathExists(targetPath);
        if (targetExists) {
            CLI.debug(`Removing "${targetPath}"...`);
            await FS_EXTRA.remove(targetPath);
        }

        CLI.debug(`Writing "${targetPath}"...`);
        await FS_EXTRA.writeFile(targetPath, parsedContent);

        CLI.debug(`Applied .cabgen ==> "${targetPath}".`);

        await FS_EXTRA.remove(templatePath);
        CLI.debug(`Removed "${templatePath}".`);
    });

    CLI.info(`Processed ${cabgenTemplates.length} **/*.cabgen templates.`);

}
